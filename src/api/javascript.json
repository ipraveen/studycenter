[{"id":"8b3eda20-a27b-11e9-9852-31af9fe893d1","question":"What will be the output of log in ES6+ environment?","ans":[{"value":"Uncaught SyntaxError: Rest parameter must be last formal parameter","isTrue":true},{"value":"1, [2, 3], 4","isTrue":false},{"value":"won't compile due to \"...\"","isTrue":false},{"value":"1, 2, 3, 4","isTrue":false}],"code":"function rest(first, ...others, last) {console.log(first, others, last);}rest(1, 2, 3, 4);","info":"Rest parameters have two restrictions. The first restriction is that there can be only one rest parameter, and the rest parameter must be last"},{"id":"8b4060c0-a27b-11e9-9852-31af9fe893d1","question":"What will be the output of log?","ans":[{"value":"3","isTrue":true},{"value":"4","isTrue":false},{"value":"0","isTrue":false},{"value":"undefined","isTrue":false}],"code":"function test(first, second, third, ...rest){}console.log(test.length);","info":"function’s length property indicates the number of named parameters for the function. However, rest parameter doesn't affect that."},{"id":"8b4087d0-a27b-11e9-9852-31af9fe893d1","question":"What will be the logs?","ans":[{"value":"In normal mode: \"true true\" and in strict mode: \"true false\"","isTrue":true},{"value":"Always \"true true\"","isTrue":false},{"value":"Always \"true false\"","isTrue":false},{"value":"ReferenceError for arguments","isTrue":false}],"code":"function testArguments(test) {console.log(test === arguments[0]);test = \"notA\";console.log(test === arguments[0]);}testArguments(\"a\");"},{"id":"8b4087d1-a27b-11e9-9852-31af9fe893d1","question":"What is the output of log statement?","ans":[{"value":"1, 2 and 3","isTrue":true},{"value":"1 and 4","isTrue":false},{"value":"1 and 2","isTrue":false},{"value":"none, it will print \"undefined undefined scope scope\"","isTrue":false}],"code":"\"use strict\";(function run(test) {console.log(value);//...........1if(test){console.log(value);//.......2let value = \"scope\";console.log(value);//.......3}console.log(value);//...........4})(true);"},{"id":"8b4087d2-a27b-11e9-9852-31af9fe893d1","question":"What is the output of log statement?","ans":[{"value":"none, it will print \"undefined undefined scope scope\"","isTrue":true},{"value":"1 and 4","isTrue":false},{"value":"1 and 2","isTrue":false},{"value":"code will fail to run","isTrue":false}],"code":"\"use strict\";(function run(test) {console.log(value);//...........1if(test){console.log(value);//.......2var value = \"scope\";console.log(value);//.......3}console.log(value);//...........4})(true);"},{"id":"8b4087d3-a27b-11e9-9852-31af9fe893d1","question":"What is the output of log statement?","ans":[{"value":"5 in general and ReferenceError in 'strict mode';","isTrue":true},{"value":"ReferenceError","isTrue":false},{"value":"syntax error","isTrue":false}],"code":"const b = 5;a = b;console.log(a);"},{"id":"8b4087d4-a27b-11e9-9852-31af9fe893d1","question":"What is the output of below code?","ans":[{"value":"`Symbol(firstName)`","isTrue":true},{"value":"`firstName`","isTrue":false},{"value":"syntax error","isTrue":false}],"code":"let firstName = Symbol(\"firstName\");console.log(firstName);"},{"id":"8b4087d5-a27b-11e9-9852-31af9fe893d1","question":"What is the output of below code?","ans":[{"value":"`undefined`","isTrue":true},{"value":"outside","isTrue":false},{"value":"inside","isTrue":false}],"code":"var text = 'outside';function logIt(){console.log(text);var text = 'inside';};logIt();"},{"id":"8b4087d6-a27b-11e9-9852-31af9fe893d1","question":"What is the output of below code?","ans":[{"value":"Uncaught TypeError: Symbol is not a constructor","isTrue":true},{"value":"`Symbol(firstName)`","isTrue":false},{"value":"`firstName`","isTrue":false},{"value":"syntax error","isTrue":false}],"code":"let firstName = new Symbol(\"firstName\");console.log(firstName);"},{"id":"8b4087d7-a27b-11e9-9852-31af9fe893d1","question":"What is the output of below code?","ans":[{"value":"foo","isTrue":true},{"value":"undefined","isTrue":false},{"value":"null","isTrue":false},{"value":"syntax error","isTrue":false}],"code":"let map = Object.create(null);let key1 = {};let key2 = {};map[key1] = \"foo\";console.log(map[key2]);","info":"<p>Object only accept a String or Number as key.</p><p>when you add an Object as key to an Object, it convert it into a String value. in this case \"[object Object]\". Now, even though key1 and key2 are different Objects, there String value is still \"[object Object]\", which same.Hence, we will get \"foo\" as output.</p>"},{"id":"8b4087d8-a27b-11e9-9852-31af9fe893d1","question":"What is the log value in first iteration","ans":[{"value":"1 1","isTrue":true},{"value":"1 0","isTrue":false},{"value":"1 Set(3) {\"1\", \"2\", \"3\"}","isTrue":false},{"value":"1 undefined","isTrue":false}],"code":"const set = new Set([\"1\", \"2\", \"3\"]);set.forEach((arg1, arg2, arg3) => {console.log(arg1, arg2);});","info":"<p>The strange difference between the set version of forEach() and the array version is that the first and second arguments to the callback function are the same. While this might look like a mistake, there’s a good reason for the behavior.</p><p>The other objects that have forEach() methods (arrays and maps) pass three arguments to their callback functions. The first two arguments for arrays and maps are the value and the key (the numeric index for arrays).Sets do not have keys, however. The people behind the ECMAScript 6 standard could have made the callback function in the set version of forEach() accept two arguments, but that would have made it different from the other two. Instead, they found a way to keep the callback function the same and accept three arguments: each value in a set is considered to be both the key and the value. As such, the first and second argument are always the same in forEach() on sets to keep this functionality consistent with the otherforEach() methods on arrays and maps.</p>"},{"id":"8b4087d9-a27b-11e9-9852-31af9fe893d1","question":"How to convert below set to array?","ans":[{"value":"[...set] or Array.from(set.values())","isTrue":true},{"value":"set.toArray()","isTrue":false},{"value":"set.values()","isTrue":false},{"value":"set.entries()","isTrue":false}],"code":"const set = new Set([\"1\", \"2\", \"3\"]);","info":"<p>Any object which return iterator, including Set, can be converted into an Array using spread notation.</p>[...set] is the quickest way.<p>Array.from(set.values()) will also work.</p>set.values() and set.entries() returns iterator and not an Array."},{"id":"8b4087da-a27b-11e9-9852-31af9fe893d1","question":"Why we do not have built-in iterators in WeakSet and WeakMap?","ans":[{"value":"Managing weak references means there’s no way to know exactly how many values are in these collections, which also means there’s no way to iterate over them.","isTrue":true},{"value":"Weak version of Set and Map are scale down version, Hence they don't have this advance feature.","isTrue":false},{"value":"For better performance","isTrue":false},{"value":"Statement is untrue.","isTrue":false}]},{"id":"8b4087db-a27b-11e9-9852-31af9fe893d1","question":"Can object be spread in Array, like below","ans":[{"value":"Yes, Only if it has a generator defined- otherwise it will give error: Uncaught TypeError: obj is not iterabl .","isTrue":true},{"value":"Yes, all object can be spread in array.","isTrue":false},{"value":"No, object can only be spread in another object.","isTrue":false}],"code":"const arr = [1, 2];const obj = {a: \"a\",b: \"b\"};const newArr = [...arr, ...obj];"}]